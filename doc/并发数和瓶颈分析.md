Date:2025.11.10
我先通读了前后端代码，重点看了服务端的请求处理、数据库访问方式、前端的请求频率与数据量，来评估 LAN 与 WAN 下的并发能力与瓶颈。
架构与通讯流简述
前端单页应用，所有 API 走 /api，JWT 放在 Authorization 头。
请求类型：
读取：GET /notes（整棵树）、GET /notes/:id（单笔记）、GET /search（全文检索）
写入：POST/PUT/DELETE /notes*（保存/移动/删除）、锁定接口、上传接口
上传：/uploadFile、/uploadAttachment（流式写盘）
关键实现特征：
所有 SQLite 操作使用 better-sqlite3 同步接口（会阻塞 Node 事件循环）。
搜索使用 LIKE '%...%' 扫描，未建全文索引。
JSON 请求体上限 2MB；自动保存周期 60s。
代码依据（仅作要点引用）：
server.jsLines 40-41
app.use(express.json({ limit: '2mb' }));app.use(express.static(path.join(__dirname, '..', 'public')));
server.jsLines 668-678
const where = 'title LIKE ? OR content_text LIKE ? OR keywords LIKE ?';const countStmt = db.prepare(`SELECT COUNT(*) AS c FROM notes WHERE ${where}`);let total = countStmt.get(like, like, like).c || 0;const listStmt = db.prepare(`  SELECT id, title, updated_at, keywords, content_text  FROM notes  WHERE ${where}  ORDER BY updated_at DESC  LIMIT ? OFFSET ?`);
主要瓶颈
同步数据库访问：每个请求中 DB 查询/更新期间会阻塞单个 Node 进程的事件循环，导致同一时刻仅能有极少数请求在“计算/DB”阶段并行。
SQLite 单写者：高并发写入会被串行化；不过本应用的写频率主要来自“手动保存+自动保存（60s一次）”，总体写入 QPS 低。
搜索未索引：LIKE '%q%' 会做全表/全列扫描，数据量增大后该接口成为明显慢请求。
前端请求特征（影响并发）
GET /notes 打开后会拉整棵树；切换/打开笔记触发 GET /notes/:id。
编辑时每 60s 自动保存一次（且手动保存/页面隐藏时也可能保存），单次 PUT 包含 Editor.js JSON（通常几十 KB，最大 2MB）。
搜索有防抖 300ms，但每次搜索是一次重查询。
并发能力估算（单进程 Node，普通 SSD，数据量中小：≤1–2万条笔记）
说明：以下为经验估值范围，真实值受 CPU/磁盘/数据量/平均 payload 影响。由于 DB 为同步阻塞，吞吐量主要看单次请求的“阻塞耗时”。
LAN（低 RTT，网络几乎不占比）
只读请求
GET /notes/:id：~2–8ms 内（简单双表 JOIN + JSON 解析）→ 约 120–400 RPS
GET /notes（整树）：~10–40ms（取全量+JS 过滤/构树）→ 25–100 RPS
GET /search：~50–200ms（LIKE 扫描）→ 5–20 RPS（该接口是主要瓶颈）
写请求
PUT /notes/:id 保存：~8–25ms（JSON 解析+扁平化+UPDATE）→ 40–120 RPS
“同时在线用户数”（混合使用，轻度搜索）
浏览为主：~100–200 人同时在线仍可用
活跃编辑（每人 60s/次自动保存）：~20–50 人同时编辑（写入被串行化但写频率低）
大文件上传：为流式 I/O，主要受磁盘与带宽限制；对 CPU/事件循环影响较小（但 JSON 路由仍受阻塞影响）
WAN（RTT 50–200ms）
服务器侧吞吐（RPS）与 LAN 基本相当（阻塞段仍相同）；用户感知时延会因网络显著上升。
“同时在线用户数”与 LAN 接近；但大文件上传对公网带宽更敏感，峰值并发上传数更多受带宽上限约束（例如 100 Mbps 仅能支撑若干路 5–10 MB/s 的并行上传）。
规模与数据量的敏感点
当笔记数达 5–10 万量级：
GET /notes 和 GET /search 耗时会明显上升（全表检索+JS 侧过滤/构树），RPS 进一步下降，建议对 title/updated_at 建索引，搜索切换到 SQLite FTS5。
大块内容（接近 2MB JSON）保存会增大 CPU 解析与写入耗时，降低写 RPS。
小结与建议（不改架构的前提下优先级）
优先优化搜索：上 FTS5 或至少对 title/updated_at 建索引，content_text 用 FTS；可把 COUNT(*) 改为近似计数或移除严格总数。
缓存整树：GET /notes 加缓存/ETag/增量加载，显著提升只读场景吞吐。
降低阻塞面：将重计算（扁平化/备份统计）移出请求关键路径，或放到子进程/Worker。
若需要更高并发：多进程（Node cluster/pm2）、或改用异步 DB/外置 DB（PostgreSQL），并将上传走专用对象存储。
LAN 粗略安全并发：浏览 100–200，活跃编辑 20–50；WAN 接近但时延更高，上传并发受带宽约束更明显。